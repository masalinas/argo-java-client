/*
 * Argo Workflows API
 * Argo Workflows is an open source container-native workflow engine for orchestrating parallel jobs on Kubernetes. For more information, please see https://argo-workflows.readthedocs.io/en/release-3.5/
 *
 * OpenAPI spec version: VERSION
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.oferto.argo.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;

import io.oferto.argo.client.model.IoArgoprojWorkflowV1alpha1Arguments;
import io.oferto.argo.client.model.IoArgoprojWorkflowV1alpha1ArtifactRepositoryRef;
import io.oferto.argo.client.model.IoArgoprojWorkflowV1alpha1ExecutorConfig;
import io.oferto.argo.client.model.IoArgoprojWorkflowV1alpha1LifecycleHook;
import io.oferto.argo.client.model.IoArgoprojWorkflowV1alpha1Metadata;
import io.oferto.argo.client.model.IoArgoprojWorkflowV1alpha1Metrics;
import io.oferto.argo.client.model.IoArgoprojWorkflowV1alpha1PodGC;
import io.oferto.argo.client.model.IoArgoprojWorkflowV1alpha1RetryStrategy;
import io.oferto.argo.client.model.IoArgoprojWorkflowV1alpha1Synchronization;
import io.oferto.argo.client.model.IoArgoprojWorkflowV1alpha1TTLStrategy;
import io.oferto.argo.client.model.IoArgoprojWorkflowV1alpha1Template;
import io.oferto.argo.client.model.IoArgoprojWorkflowV1alpha1VolumeClaimGC;
import io.oferto.argo.client.model.IoArgoprojWorkflowV1alpha1WorkflowLevelArtifactGC;
import io.oferto.argo.client.model.IoArgoprojWorkflowV1alpha1WorkflowMetadata;
import io.oferto.argo.client.model.IoArgoprojWorkflowV1alpha1WorkflowTemplateRef;
import io.oferto.argo.client.model.IoK8sApiCoreV1Affinity;
import io.oferto.argo.client.model.IoK8sApiCoreV1HostAlias;
import io.oferto.argo.client.model.IoK8sApiCoreV1LocalObjectReference;
import io.oferto.argo.client.model.IoK8sApiCoreV1PersistentVolumeClaim;
import io.oferto.argo.client.model.IoK8sApiCoreV1PodDNSConfig;
import io.oferto.argo.client.model.IoK8sApiCoreV1PodSecurityContext;
import io.oferto.argo.client.model.IoK8sApiCoreV1Toleration;
import io.oferto.argo.client.model.IoK8sApiCoreV1Volume;
import io.oferto.argo.client.model.IoK8sApiPolicyV1PodDisruptionBudgetSpec;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * WorkflowSpec is the specification of a Workflow.
 */
@ApiModel(description = "WorkflowSpec is the specification of a Workflow.")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2024-03-17T20:59:50.224Z")
public class IoArgoprojWorkflowV1alpha1WorkflowSpec {
  @SerializedName("activeDeadlineSeconds")
  private Integer activeDeadlineSeconds = null;

  @SerializedName("affinity")
  private IoK8sApiCoreV1Affinity affinity = null;

  @SerializedName("archiveLogs")
  private Boolean archiveLogs = null;

  @SerializedName("arguments")
  private IoArgoprojWorkflowV1alpha1Arguments arguments = null;

  @SerializedName("artifactGC")
  private IoArgoprojWorkflowV1alpha1WorkflowLevelArtifactGC artifactGC = null;

  @SerializedName("artifactRepositoryRef")
  private IoArgoprojWorkflowV1alpha1ArtifactRepositoryRef artifactRepositoryRef = null;

  @SerializedName("automountServiceAccountToken")
  private Boolean automountServiceAccountToken = null;

  @SerializedName("dnsConfig")
  private IoK8sApiCoreV1PodDNSConfig dnsConfig = null;

  @SerializedName("dnsPolicy")
  private String dnsPolicy = null;

  @SerializedName("entrypoint")
  private String entrypoint = null;

  @SerializedName("executor")
  private IoArgoprojWorkflowV1alpha1ExecutorConfig executor = null;

  @SerializedName("hooks")
  private Map<String, IoArgoprojWorkflowV1alpha1LifecycleHook> hooks = null;

  @SerializedName("hostAliases")
  private List<IoK8sApiCoreV1HostAlias> hostAliases = null;

  @SerializedName("hostNetwork")
  private Boolean hostNetwork = null;

  @SerializedName("imagePullSecrets")
  private List<IoK8sApiCoreV1LocalObjectReference> imagePullSecrets = null;

  @SerializedName("metrics")
  private IoArgoprojWorkflowV1alpha1Metrics metrics = null;

  @SerializedName("nodeSelector")
  private Map<String, String> nodeSelector = null;

  @SerializedName("onExit")
  private String onExit = null;

  @SerializedName("parallelism")
  private Integer parallelism = null;

  @SerializedName("podDisruptionBudget")
  private IoK8sApiPolicyV1PodDisruptionBudgetSpec podDisruptionBudget = null;

  @SerializedName("podGC")
  private IoArgoprojWorkflowV1alpha1PodGC podGC = null;

  @SerializedName("podMetadata")
  private IoArgoprojWorkflowV1alpha1Metadata podMetadata = null;

  @SerializedName("podPriority")
  private Integer podPriority = null;

  @SerializedName("podPriorityClassName")
  private String podPriorityClassName = null;

  @SerializedName("podSpecPatch")
  private String podSpecPatch = null;

  @SerializedName("priority")
  private Integer priority = null;

  @SerializedName("retryStrategy")
  private IoArgoprojWorkflowV1alpha1RetryStrategy retryStrategy = null;

  @SerializedName("schedulerName")
  private String schedulerName = null;

  @SerializedName("securityContext")
  private IoK8sApiCoreV1PodSecurityContext securityContext = null;

  @SerializedName("serviceAccountName")
  private String serviceAccountName = null;

  @SerializedName("shutdown")
  private String shutdown = null;

  @SerializedName("suspend")
  private Boolean suspend = null;

  @SerializedName("synchronization")
  private IoArgoprojWorkflowV1alpha1Synchronization synchronization = null;

  @SerializedName("templateDefaults")
  private IoArgoprojWorkflowV1alpha1Template templateDefaults = null;

  @SerializedName("templates")
  private List<IoArgoprojWorkflowV1alpha1Template> templates = null;

  @SerializedName("tolerations")
  private List<IoK8sApiCoreV1Toleration> tolerations = null;

  @SerializedName("ttlStrategy")
  private IoArgoprojWorkflowV1alpha1TTLStrategy ttlStrategy = null;

  @SerializedName("volumeClaimGC")
  private IoArgoprojWorkflowV1alpha1VolumeClaimGC volumeClaimGC = null;

  @SerializedName("volumeClaimTemplates")
  private List<IoK8sApiCoreV1PersistentVolumeClaim> volumeClaimTemplates = null;

  @SerializedName("volumes")
  private List<IoK8sApiCoreV1Volume> volumes = null;

  @SerializedName("workflowMetadata")
  private IoArgoprojWorkflowV1alpha1WorkflowMetadata workflowMetadata = null;

  @SerializedName("workflowTemplateRef")
  private IoArgoprojWorkflowV1alpha1WorkflowTemplateRef workflowTemplateRef = null;

  public IoArgoprojWorkflowV1alpha1WorkflowSpec activeDeadlineSeconds(Integer activeDeadlineSeconds) {
    this.activeDeadlineSeconds = activeDeadlineSeconds;
    return this;
  }

   /**
   * Optional duration in seconds relative to the workflow start time which the workflow is allowed to run before the controller terminates the io.argoproj.workflow.v1alpha1. A value of zero is used to terminate a Running workflow
   * @return activeDeadlineSeconds
  **/
  @ApiModelProperty(value = "Optional duration in seconds relative to the workflow start time which the workflow is allowed to run before the controller terminates the io.argoproj.workflow.v1alpha1. A value of zero is used to terminate a Running workflow")
  public Integer getActiveDeadlineSeconds() {
    return activeDeadlineSeconds;
  }

  public void setActiveDeadlineSeconds(Integer activeDeadlineSeconds) {
    this.activeDeadlineSeconds = activeDeadlineSeconds;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec affinity(IoK8sApiCoreV1Affinity affinity) {
    this.affinity = affinity;
    return this;
  }

   /**
   * Affinity sets the scheduling constraints for all pods in the io.argoproj.workflow.v1alpha1. Can be overridden by an affinity specified in the template
   * @return affinity
  **/
  @ApiModelProperty(value = "Affinity sets the scheduling constraints for all pods in the io.argoproj.workflow.v1alpha1. Can be overridden by an affinity specified in the template")
  public IoK8sApiCoreV1Affinity getAffinity() {
    return affinity;
  }

  public void setAffinity(IoK8sApiCoreV1Affinity affinity) {
    this.affinity = affinity;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec archiveLogs(Boolean archiveLogs) {
    this.archiveLogs = archiveLogs;
    return this;
  }

   /**
   * ArchiveLogs indicates if the container logs should be archived
   * @return archiveLogs
  **/
  @ApiModelProperty(value = "ArchiveLogs indicates if the container logs should be archived")
  public Boolean isArchiveLogs() {
    return archiveLogs;
  }

  public void setArchiveLogs(Boolean archiveLogs) {
    this.archiveLogs = archiveLogs;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec arguments(IoArgoprojWorkflowV1alpha1Arguments arguments) {
    this.arguments = arguments;
    return this;
  }

   /**
   * Arguments contain the parameters and artifacts sent to the workflow entrypoint Parameters are referencable globally using the &#39;workflow&#39; variable prefix. e.g. {{io.argoproj.workflow.v1alpha1.parameters.myparam}}
   * @return arguments
  **/
  @ApiModelProperty(value = "Arguments contain the parameters and artifacts sent to the workflow entrypoint Parameters are referencable globally using the 'workflow' variable prefix. e.g. {{io.argoproj.workflow.v1alpha1.parameters.myparam}}")
  public IoArgoprojWorkflowV1alpha1Arguments getArguments() {
    return arguments;
  }

  public void setArguments(IoArgoprojWorkflowV1alpha1Arguments arguments) {
    this.arguments = arguments;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec artifactGC(IoArgoprojWorkflowV1alpha1WorkflowLevelArtifactGC artifactGC) {
    this.artifactGC = artifactGC;
    return this;
  }

   /**
   * ArtifactGC describes the strategy to use when deleting artifacts from completed or deleted workflows (applies to all output Artifacts unless Artifact.ArtifactGC is specified, which overrides this)
   * @return artifactGC
  **/
  @ApiModelProperty(value = "ArtifactGC describes the strategy to use when deleting artifacts from completed or deleted workflows (applies to all output Artifacts unless Artifact.ArtifactGC is specified, which overrides this)")
  public IoArgoprojWorkflowV1alpha1WorkflowLevelArtifactGC getArtifactGC() {
    return artifactGC;
  }

  public void setArtifactGC(IoArgoprojWorkflowV1alpha1WorkflowLevelArtifactGC artifactGC) {
    this.artifactGC = artifactGC;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec artifactRepositoryRef(IoArgoprojWorkflowV1alpha1ArtifactRepositoryRef artifactRepositoryRef) {
    this.artifactRepositoryRef = artifactRepositoryRef;
    return this;
  }

   /**
   * ArtifactRepositoryRef specifies the configMap name and key containing the artifact repository config.
   * @return artifactRepositoryRef
  **/
  @ApiModelProperty(value = "ArtifactRepositoryRef specifies the configMap name and key containing the artifact repository config.")
  public IoArgoprojWorkflowV1alpha1ArtifactRepositoryRef getArtifactRepositoryRef() {
    return artifactRepositoryRef;
  }

  public void setArtifactRepositoryRef(IoArgoprojWorkflowV1alpha1ArtifactRepositoryRef artifactRepositoryRef) {
    this.artifactRepositoryRef = artifactRepositoryRef;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec automountServiceAccountToken(Boolean automountServiceAccountToken) {
    this.automountServiceAccountToken = automountServiceAccountToken;
    return this;
  }

   /**
   * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted in pods. ServiceAccountName of ExecutorConfig must be specified if this value is false.
   * @return automountServiceAccountToken
  **/
  @ApiModelProperty(value = "AutomountServiceAccountToken indicates whether a service account token should be automatically mounted in pods. ServiceAccountName of ExecutorConfig must be specified if this value is false.")
  public Boolean isAutomountServiceAccountToken() {
    return automountServiceAccountToken;
  }

  public void setAutomountServiceAccountToken(Boolean automountServiceAccountToken) {
    this.automountServiceAccountToken = automountServiceAccountToken;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec dnsConfig(IoK8sApiCoreV1PodDNSConfig dnsConfig) {
    this.dnsConfig = dnsConfig;
    return this;
  }

   /**
   * PodDNSConfig defines the DNS parameters of a pod in addition to those generated from DNSPolicy.
   * @return dnsConfig
  **/
  @ApiModelProperty(value = "PodDNSConfig defines the DNS parameters of a pod in addition to those generated from DNSPolicy.")
  public IoK8sApiCoreV1PodDNSConfig getDnsConfig() {
    return dnsConfig;
  }

  public void setDnsConfig(IoK8sApiCoreV1PodDNSConfig dnsConfig) {
    this.dnsConfig = dnsConfig;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec dnsPolicy(String dnsPolicy) {
    this.dnsPolicy = dnsPolicy;
    return this;
  }

   /**
   * Set DNS policy for the pod. Defaults to \&quot;ClusterFirst\&quot;. Valid values are &#39;ClusterFirstWithHostNet&#39;, &#39;ClusterFirst&#39;, &#39;Default&#39; or &#39;None&#39;. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to &#39;ClusterFirstWithHostNet&#39;.
   * @return dnsPolicy
  **/
  @ApiModelProperty(value = "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.")
  public String getDnsPolicy() {
    return dnsPolicy;
  }

  public void setDnsPolicy(String dnsPolicy) {
    this.dnsPolicy = dnsPolicy;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec entrypoint(String entrypoint) {
    this.entrypoint = entrypoint;
    return this;
  }

   /**
   * Entrypoint is a template reference to the starting point of the io.argoproj.workflow.v1alpha1.
   * @return entrypoint
  **/
  @ApiModelProperty(value = "Entrypoint is a template reference to the starting point of the io.argoproj.workflow.v1alpha1.")
  public String getEntrypoint() {
    return entrypoint;
  }

  public void setEntrypoint(String entrypoint) {
    this.entrypoint = entrypoint;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec executor(IoArgoprojWorkflowV1alpha1ExecutorConfig executor) {
    this.executor = executor;
    return this;
  }

   /**
   * Executor holds configurations of executor containers of the io.argoproj.workflow.v1alpha1.
   * @return executor
  **/
  @ApiModelProperty(value = "Executor holds configurations of executor containers of the io.argoproj.workflow.v1alpha1.")
  public IoArgoprojWorkflowV1alpha1ExecutorConfig getExecutor() {
    return executor;
  }

  public void setExecutor(IoArgoprojWorkflowV1alpha1ExecutorConfig executor) {
    this.executor = executor;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec hooks(Map<String, IoArgoprojWorkflowV1alpha1LifecycleHook> hooks) {
    this.hooks = hooks;
    return this;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec putHooksItem(String key, IoArgoprojWorkflowV1alpha1LifecycleHook hooksItem) {
    if (this.hooks == null) {
      this.hooks = new HashMap<String, IoArgoprojWorkflowV1alpha1LifecycleHook>();
    }
    this.hooks.put(key, hooksItem);
    return this;
  }

   /**
   * Hooks holds the lifecycle hook which is invoked at lifecycle of step, irrespective of the success, failure, or error status of the primary step
   * @return hooks
  **/
  @ApiModelProperty(value = "Hooks holds the lifecycle hook which is invoked at lifecycle of step, irrespective of the success, failure, or error status of the primary step")
  public Map<String, IoArgoprojWorkflowV1alpha1LifecycleHook> getHooks() {
    return hooks;
  }

  public void setHooks(Map<String, IoArgoprojWorkflowV1alpha1LifecycleHook> hooks) {
    this.hooks = hooks;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec hostAliases(List<IoK8sApiCoreV1HostAlias> hostAliases) {
    this.hostAliases = hostAliases;
    return this;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec addHostAliasesItem(IoK8sApiCoreV1HostAlias hostAliasesItem) {
    if (this.hostAliases == null) {
      this.hostAliases = new ArrayList<IoK8sApiCoreV1HostAlias>();
    }
    this.hostAliases.add(hostAliasesItem);
    return this;
  }

   /**
   * Get hostAliases
   * @return hostAliases
  **/
  @ApiModelProperty(value = "")
  public List<IoK8sApiCoreV1HostAlias> getHostAliases() {
    return hostAliases;
  }

  public void setHostAliases(List<IoK8sApiCoreV1HostAlias> hostAliases) {
    this.hostAliases = hostAliases;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec hostNetwork(Boolean hostNetwork) {
    this.hostNetwork = hostNetwork;
    return this;
  }

   /**
   * Host networking requested for this workflow pod. Default to false.
   * @return hostNetwork
  **/
  @ApiModelProperty(value = "Host networking requested for this workflow pod. Default to false.")
  public Boolean isHostNetwork() {
    return hostNetwork;
  }

  public void setHostNetwork(Boolean hostNetwork) {
    this.hostNetwork = hostNetwork;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec imagePullSecrets(List<IoK8sApiCoreV1LocalObjectReference> imagePullSecrets) {
    this.imagePullSecrets = imagePullSecrets;
    return this;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec addImagePullSecretsItem(IoK8sApiCoreV1LocalObjectReference imagePullSecretsItem) {
    if (this.imagePullSecrets == null) {
      this.imagePullSecrets = new ArrayList<IoK8sApiCoreV1LocalObjectReference>();
    }
    this.imagePullSecrets.add(imagePullSecretsItem);
    return this;
  }

   /**
   * ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images in pods that reference this ServiceAccount. ImagePullSecrets are distinct from Secrets because Secrets can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet. More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
   * @return imagePullSecrets
  **/
  @ApiModelProperty(value = "ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images in pods that reference this ServiceAccount. ImagePullSecrets are distinct from Secrets because Secrets can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet. More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod")
  public List<IoK8sApiCoreV1LocalObjectReference> getImagePullSecrets() {
    return imagePullSecrets;
  }

  public void setImagePullSecrets(List<IoK8sApiCoreV1LocalObjectReference> imagePullSecrets) {
    this.imagePullSecrets = imagePullSecrets;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec metrics(IoArgoprojWorkflowV1alpha1Metrics metrics) {
    this.metrics = metrics;
    return this;
  }

   /**
   * Metrics are a list of metrics emitted from this Workflow
   * @return metrics
  **/
  @ApiModelProperty(value = "Metrics are a list of metrics emitted from this Workflow")
  public IoArgoprojWorkflowV1alpha1Metrics getMetrics() {
    return metrics;
  }

  public void setMetrics(IoArgoprojWorkflowV1alpha1Metrics metrics) {
    this.metrics = metrics;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec nodeSelector(Map<String, String> nodeSelector) {
    this.nodeSelector = nodeSelector;
    return this;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec putNodeSelectorItem(String key, String nodeSelectorItem) {
    if (this.nodeSelector == null) {
      this.nodeSelector = new HashMap<String, String>();
    }
    this.nodeSelector.put(key, nodeSelectorItem);
    return this;
  }

   /**
   * NodeSelector is a selector which will result in all pods of the workflow to be scheduled on the selected node(s). This is able to be overridden by a nodeSelector specified in the template.
   * @return nodeSelector
  **/
  @ApiModelProperty(value = "NodeSelector is a selector which will result in all pods of the workflow to be scheduled on the selected node(s). This is able to be overridden by a nodeSelector specified in the template.")
  public Map<String, String> getNodeSelector() {
    return nodeSelector;
  }

  public void setNodeSelector(Map<String, String> nodeSelector) {
    this.nodeSelector = nodeSelector;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec onExit(String onExit) {
    this.onExit = onExit;
    return this;
  }

   /**
   * OnExit is a template reference which is invoked at the end of the workflow, irrespective of the success, failure, or error of the primary io.argoproj.workflow.v1alpha1.
   * @return onExit
  **/
  @ApiModelProperty(value = "OnExit is a template reference which is invoked at the end of the workflow, irrespective of the success, failure, or error of the primary io.argoproj.workflow.v1alpha1.")
  public String getOnExit() {
    return onExit;
  }

  public void setOnExit(String onExit) {
    this.onExit = onExit;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec parallelism(Integer parallelism) {
    this.parallelism = parallelism;
    return this;
  }

   /**
   * Parallelism limits the max total parallel pods that can execute at the same time in a workflow
   * @return parallelism
  **/
  @ApiModelProperty(value = "Parallelism limits the max total parallel pods that can execute at the same time in a workflow")
  public Integer getParallelism() {
    return parallelism;
  }

  public void setParallelism(Integer parallelism) {
    this.parallelism = parallelism;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec podDisruptionBudget(IoK8sApiPolicyV1PodDisruptionBudgetSpec podDisruptionBudget) {
    this.podDisruptionBudget = podDisruptionBudget;
    return this;
  }

   /**
   * PodDisruptionBudget holds the number of concurrent disruptions that you allow for Workflow&#39;s Pods. Controller will automatically add the selector with workflow name, if selector is empty. Optional: Defaults to empty.
   * @return podDisruptionBudget
  **/
  @ApiModelProperty(value = "PodDisruptionBudget holds the number of concurrent disruptions that you allow for Workflow's Pods. Controller will automatically add the selector with workflow name, if selector is empty. Optional: Defaults to empty.")
  public IoK8sApiPolicyV1PodDisruptionBudgetSpec getPodDisruptionBudget() {
    return podDisruptionBudget;
  }

  public void setPodDisruptionBudget(IoK8sApiPolicyV1PodDisruptionBudgetSpec podDisruptionBudget) {
    this.podDisruptionBudget = podDisruptionBudget;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec podGC(IoArgoprojWorkflowV1alpha1PodGC podGC) {
    this.podGC = podGC;
    return this;
  }

   /**
   * PodGC describes the strategy to use when deleting completed pods
   * @return podGC
  **/
  @ApiModelProperty(value = "PodGC describes the strategy to use when deleting completed pods")
  public IoArgoprojWorkflowV1alpha1PodGC getPodGC() {
    return podGC;
  }

  public void setPodGC(IoArgoprojWorkflowV1alpha1PodGC podGC) {
    this.podGC = podGC;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec podMetadata(IoArgoprojWorkflowV1alpha1Metadata podMetadata) {
    this.podMetadata = podMetadata;
    return this;
  }

   /**
   * PodMetadata defines additional metadata that should be applied to workflow pods
   * @return podMetadata
  **/
  @ApiModelProperty(value = "PodMetadata defines additional metadata that should be applied to workflow pods")
  public IoArgoprojWorkflowV1alpha1Metadata getPodMetadata() {
    return podMetadata;
  }

  public void setPodMetadata(IoArgoprojWorkflowV1alpha1Metadata podMetadata) {
    this.podMetadata = podMetadata;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec podPriority(Integer podPriority) {
    this.podPriority = podPriority;
    return this;
  }

   /**
   * Priority to apply to workflow pods. DEPRECATED: Use PodPriorityClassName instead.
   * @return podPriority
  **/
  @ApiModelProperty(value = "Priority to apply to workflow pods. DEPRECATED: Use PodPriorityClassName instead.")
  public Integer getPodPriority() {
    return podPriority;
  }

  public void setPodPriority(Integer podPriority) {
    this.podPriority = podPriority;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec podPriorityClassName(String podPriorityClassName) {
    this.podPriorityClassName = podPriorityClassName;
    return this;
  }

   /**
   * PriorityClassName to apply to workflow pods.
   * @return podPriorityClassName
  **/
  @ApiModelProperty(value = "PriorityClassName to apply to workflow pods.")
  public String getPodPriorityClassName() {
    return podPriorityClassName;
  }

  public void setPodPriorityClassName(String podPriorityClassName) {
    this.podPriorityClassName = podPriorityClassName;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec podSpecPatch(String podSpecPatch) {
    this.podSpecPatch = podSpecPatch;
    return this;
  }

   /**
   * PodSpecPatch holds strategic merge patch to apply against the pod spec. Allows parameterization of container fields which are not strings (e.g. resource limits).
   * @return podSpecPatch
  **/
  @ApiModelProperty(value = "PodSpecPatch holds strategic merge patch to apply against the pod spec. Allows parameterization of container fields which are not strings (e.g. resource limits).")
  public String getPodSpecPatch() {
    return podSpecPatch;
  }

  public void setPodSpecPatch(String podSpecPatch) {
    this.podSpecPatch = podSpecPatch;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec priority(Integer priority) {
    this.priority = priority;
    return this;
  }

   /**
   * Priority is used if controller is configured to process limited number of workflows in parallel. Workflows with higher priority are processed first.
   * @return priority
  **/
  @ApiModelProperty(value = "Priority is used if controller is configured to process limited number of workflows in parallel. Workflows with higher priority are processed first.")
  public Integer getPriority() {
    return priority;
  }

  public void setPriority(Integer priority) {
    this.priority = priority;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec retryStrategy(IoArgoprojWorkflowV1alpha1RetryStrategy retryStrategy) {
    this.retryStrategy = retryStrategy;
    return this;
  }

   /**
   * RetryStrategy for all templates in the io.argoproj.workflow.v1alpha1.
   * @return retryStrategy
  **/
  @ApiModelProperty(value = "RetryStrategy for all templates in the io.argoproj.workflow.v1alpha1.")
  public IoArgoprojWorkflowV1alpha1RetryStrategy getRetryStrategy() {
    return retryStrategy;
  }

  public void setRetryStrategy(IoArgoprojWorkflowV1alpha1RetryStrategy retryStrategy) {
    this.retryStrategy = retryStrategy;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec schedulerName(String schedulerName) {
    this.schedulerName = schedulerName;
    return this;
  }

   /**
   * Set scheduler name for all pods. Will be overridden if container/script template&#39;s scheduler name is set. Default scheduler will be used if neither specified.
   * @return schedulerName
  **/
  @ApiModelProperty(value = "Set scheduler name for all pods. Will be overridden if container/script template's scheduler name is set. Default scheduler will be used if neither specified.")
  public String getSchedulerName() {
    return schedulerName;
  }

  public void setSchedulerName(String schedulerName) {
    this.schedulerName = schedulerName;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec securityContext(IoK8sApiCoreV1PodSecurityContext securityContext) {
    this.securityContext = securityContext;
    return this;
  }

   /**
   * SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.
   * @return securityContext
  **/
  @ApiModelProperty(value = "SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.")
  public IoK8sApiCoreV1PodSecurityContext getSecurityContext() {
    return securityContext;
  }

  public void setSecurityContext(IoK8sApiCoreV1PodSecurityContext securityContext) {
    this.securityContext = securityContext;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec serviceAccountName(String serviceAccountName) {
    this.serviceAccountName = serviceAccountName;
    return this;
  }

   /**
   * ServiceAccountName is the name of the ServiceAccount to run all pods of the workflow as.
   * @return serviceAccountName
  **/
  @ApiModelProperty(value = "ServiceAccountName is the name of the ServiceAccount to run all pods of the workflow as.")
  public String getServiceAccountName() {
    return serviceAccountName;
  }

  public void setServiceAccountName(String serviceAccountName) {
    this.serviceAccountName = serviceAccountName;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec shutdown(String shutdown) {
    this.shutdown = shutdown;
    return this;
  }

   /**
   * Shutdown will shutdown the workflow according to its ShutdownStrategy
   * @return shutdown
  **/
  @ApiModelProperty(value = "Shutdown will shutdown the workflow according to its ShutdownStrategy")
  public String getShutdown() {
    return shutdown;
  }

  public void setShutdown(String shutdown) {
    this.shutdown = shutdown;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec suspend(Boolean suspend) {
    this.suspend = suspend;
    return this;
  }

   /**
   * Suspend will suspend the workflow and prevent execution of any future steps in the workflow
   * @return suspend
  **/
  @ApiModelProperty(value = "Suspend will suspend the workflow and prevent execution of any future steps in the workflow")
  public Boolean isSuspend() {
    return suspend;
  }

  public void setSuspend(Boolean suspend) {
    this.suspend = suspend;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec synchronization(IoArgoprojWorkflowV1alpha1Synchronization synchronization) {
    this.synchronization = synchronization;
    return this;
  }

   /**
   * Synchronization holds synchronization lock configuration for this Workflow
   * @return synchronization
  **/
  @ApiModelProperty(value = "Synchronization holds synchronization lock configuration for this Workflow")
  public IoArgoprojWorkflowV1alpha1Synchronization getSynchronization() {
    return synchronization;
  }

  public void setSynchronization(IoArgoprojWorkflowV1alpha1Synchronization synchronization) {
    this.synchronization = synchronization;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec templateDefaults(IoArgoprojWorkflowV1alpha1Template templateDefaults) {
    this.templateDefaults = templateDefaults;
    return this;
  }

   /**
   * TemplateDefaults holds default template values that will apply to all templates in the Workflow, unless overridden on the template-level
   * @return templateDefaults
  **/
  @ApiModelProperty(value = "TemplateDefaults holds default template values that will apply to all templates in the Workflow, unless overridden on the template-level")
  public IoArgoprojWorkflowV1alpha1Template getTemplateDefaults() {
    return templateDefaults;
  }

  public void setTemplateDefaults(IoArgoprojWorkflowV1alpha1Template templateDefaults) {
    this.templateDefaults = templateDefaults;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec templates(List<IoArgoprojWorkflowV1alpha1Template> templates) {
    this.templates = templates;
    return this;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec addTemplatesItem(IoArgoprojWorkflowV1alpha1Template templatesItem) {
    if (this.templates == null) {
      this.templates = new ArrayList<IoArgoprojWorkflowV1alpha1Template>();
    }
    this.templates.add(templatesItem);
    return this;
  }

   /**
   * Templates is a list of workflow templates used in a workflow
   * @return templates
  **/
  @ApiModelProperty(value = "Templates is a list of workflow templates used in a workflow")
  public List<IoArgoprojWorkflowV1alpha1Template> getTemplates() {
    return templates;
  }

  public void setTemplates(List<IoArgoprojWorkflowV1alpha1Template> templates) {
    this.templates = templates;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec tolerations(List<IoK8sApiCoreV1Toleration> tolerations) {
    this.tolerations = tolerations;
    return this;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec addTolerationsItem(IoK8sApiCoreV1Toleration tolerationsItem) {
    if (this.tolerations == null) {
      this.tolerations = new ArrayList<IoK8sApiCoreV1Toleration>();
    }
    this.tolerations.add(tolerationsItem);
    return this;
  }

   /**
   * Tolerations to apply to workflow pods.
   * @return tolerations
  **/
  @ApiModelProperty(value = "Tolerations to apply to workflow pods.")
  public List<IoK8sApiCoreV1Toleration> getTolerations() {
    return tolerations;
  }

  public void setTolerations(List<IoK8sApiCoreV1Toleration> tolerations) {
    this.tolerations = tolerations;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec ttlStrategy(IoArgoprojWorkflowV1alpha1TTLStrategy ttlStrategy) {
    this.ttlStrategy = ttlStrategy;
    return this;
  }

   /**
   * TTLStrategy limits the lifetime of a Workflow that has finished execution depending on if it Succeeded or Failed. If this struct is set, once the Workflow finishes, it will be deleted after the time to live expires. If this field is unset, the controller config map will hold the default values.
   * @return ttlStrategy
  **/
  @ApiModelProperty(value = "TTLStrategy limits the lifetime of a Workflow that has finished execution depending on if it Succeeded or Failed. If this struct is set, once the Workflow finishes, it will be deleted after the time to live expires. If this field is unset, the controller config map will hold the default values.")
  public IoArgoprojWorkflowV1alpha1TTLStrategy getTtlStrategy() {
    return ttlStrategy;
  }

  public void setTtlStrategy(IoArgoprojWorkflowV1alpha1TTLStrategy ttlStrategy) {
    this.ttlStrategy = ttlStrategy;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec volumeClaimGC(IoArgoprojWorkflowV1alpha1VolumeClaimGC volumeClaimGC) {
    this.volumeClaimGC = volumeClaimGC;
    return this;
  }

   /**
   * VolumeClaimGC describes the strategy to use when deleting volumes from completed workflows
   * @return volumeClaimGC
  **/
  @ApiModelProperty(value = "VolumeClaimGC describes the strategy to use when deleting volumes from completed workflows")
  public IoArgoprojWorkflowV1alpha1VolumeClaimGC getVolumeClaimGC() {
    return volumeClaimGC;
  }

  public void setVolumeClaimGC(IoArgoprojWorkflowV1alpha1VolumeClaimGC volumeClaimGC) {
    this.volumeClaimGC = volumeClaimGC;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec volumeClaimTemplates(List<IoK8sApiCoreV1PersistentVolumeClaim> volumeClaimTemplates) {
    this.volumeClaimTemplates = volumeClaimTemplates;
    return this;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec addVolumeClaimTemplatesItem(IoK8sApiCoreV1PersistentVolumeClaim volumeClaimTemplatesItem) {
    if (this.volumeClaimTemplates == null) {
      this.volumeClaimTemplates = new ArrayList<IoK8sApiCoreV1PersistentVolumeClaim>();
    }
    this.volumeClaimTemplates.add(volumeClaimTemplatesItem);
    return this;
  }

   /**
   * VolumeClaimTemplates is a list of claims that containers are allowed to reference. The Workflow controller will create the claims at the beginning of the workflow and delete the claims upon completion of the workflow
   * @return volumeClaimTemplates
  **/
  @ApiModelProperty(value = "VolumeClaimTemplates is a list of claims that containers are allowed to reference. The Workflow controller will create the claims at the beginning of the workflow and delete the claims upon completion of the workflow")
  public List<IoK8sApiCoreV1PersistentVolumeClaim> getVolumeClaimTemplates() {
    return volumeClaimTemplates;
  }

  public void setVolumeClaimTemplates(List<IoK8sApiCoreV1PersistentVolumeClaim> volumeClaimTemplates) {
    this.volumeClaimTemplates = volumeClaimTemplates;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec volumes(List<IoK8sApiCoreV1Volume> volumes) {
    this.volumes = volumes;
    return this;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec addVolumesItem(IoK8sApiCoreV1Volume volumesItem) {
    if (this.volumes == null) {
      this.volumes = new ArrayList<IoK8sApiCoreV1Volume>();
    }
    this.volumes.add(volumesItem);
    return this;
  }

   /**
   * Volumes is a list of volumes that can be mounted by containers in a io.argoproj.workflow.v1alpha1.
   * @return volumes
  **/
  @ApiModelProperty(value = "Volumes is a list of volumes that can be mounted by containers in a io.argoproj.workflow.v1alpha1.")
  public List<IoK8sApiCoreV1Volume> getVolumes() {
    return volumes;
  }

  public void setVolumes(List<IoK8sApiCoreV1Volume> volumes) {
    this.volumes = volumes;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec workflowMetadata(IoArgoprojWorkflowV1alpha1WorkflowMetadata workflowMetadata) {
    this.workflowMetadata = workflowMetadata;
    return this;
  }

   /**
   * WorkflowMetadata contains some metadata of the workflow to refer to
   * @return workflowMetadata
  **/
  @ApiModelProperty(value = "WorkflowMetadata contains some metadata of the workflow to refer to")
  public IoArgoprojWorkflowV1alpha1WorkflowMetadata getWorkflowMetadata() {
    return workflowMetadata;
  }

  public void setWorkflowMetadata(IoArgoprojWorkflowV1alpha1WorkflowMetadata workflowMetadata) {
    this.workflowMetadata = workflowMetadata;
  }

  public IoArgoprojWorkflowV1alpha1WorkflowSpec workflowTemplateRef(IoArgoprojWorkflowV1alpha1WorkflowTemplateRef workflowTemplateRef) {
    this.workflowTemplateRef = workflowTemplateRef;
    return this;
  }

   /**
   * WorkflowTemplateRef holds a reference to a WorkflowTemplate for execution
   * @return workflowTemplateRef
  **/
  @ApiModelProperty(value = "WorkflowTemplateRef holds a reference to a WorkflowTemplate for execution")
  public IoArgoprojWorkflowV1alpha1WorkflowTemplateRef getWorkflowTemplateRef() {
    return workflowTemplateRef;
  }

  public void setWorkflowTemplateRef(IoArgoprojWorkflowV1alpha1WorkflowTemplateRef workflowTemplateRef) {
    this.workflowTemplateRef = workflowTemplateRef;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    IoArgoprojWorkflowV1alpha1WorkflowSpec ioArgoprojWorkflowV1alpha1WorkflowSpec = (IoArgoprojWorkflowV1alpha1WorkflowSpec) o;
    return Objects.equals(this.activeDeadlineSeconds, ioArgoprojWorkflowV1alpha1WorkflowSpec.activeDeadlineSeconds) &&
        Objects.equals(this.affinity, ioArgoprojWorkflowV1alpha1WorkflowSpec.affinity) &&
        Objects.equals(this.archiveLogs, ioArgoprojWorkflowV1alpha1WorkflowSpec.archiveLogs) &&
        Objects.equals(this.arguments, ioArgoprojWorkflowV1alpha1WorkflowSpec.arguments) &&
        Objects.equals(this.artifactGC, ioArgoprojWorkflowV1alpha1WorkflowSpec.artifactGC) &&
        Objects.equals(this.artifactRepositoryRef, ioArgoprojWorkflowV1alpha1WorkflowSpec.artifactRepositoryRef) &&
        Objects.equals(this.automountServiceAccountToken, ioArgoprojWorkflowV1alpha1WorkflowSpec.automountServiceAccountToken) &&
        Objects.equals(this.dnsConfig, ioArgoprojWorkflowV1alpha1WorkflowSpec.dnsConfig) &&
        Objects.equals(this.dnsPolicy, ioArgoprojWorkflowV1alpha1WorkflowSpec.dnsPolicy) &&
        Objects.equals(this.entrypoint, ioArgoprojWorkflowV1alpha1WorkflowSpec.entrypoint) &&
        Objects.equals(this.executor, ioArgoprojWorkflowV1alpha1WorkflowSpec.executor) &&
        Objects.equals(this.hooks, ioArgoprojWorkflowV1alpha1WorkflowSpec.hooks) &&
        Objects.equals(this.hostAliases, ioArgoprojWorkflowV1alpha1WorkflowSpec.hostAliases) &&
        Objects.equals(this.hostNetwork, ioArgoprojWorkflowV1alpha1WorkflowSpec.hostNetwork) &&
        Objects.equals(this.imagePullSecrets, ioArgoprojWorkflowV1alpha1WorkflowSpec.imagePullSecrets) &&
        Objects.equals(this.metrics, ioArgoprojWorkflowV1alpha1WorkflowSpec.metrics) &&
        Objects.equals(this.nodeSelector, ioArgoprojWorkflowV1alpha1WorkflowSpec.nodeSelector) &&
        Objects.equals(this.onExit, ioArgoprojWorkflowV1alpha1WorkflowSpec.onExit) &&
        Objects.equals(this.parallelism, ioArgoprojWorkflowV1alpha1WorkflowSpec.parallelism) &&
        Objects.equals(this.podDisruptionBudget, ioArgoprojWorkflowV1alpha1WorkflowSpec.podDisruptionBudget) &&
        Objects.equals(this.podGC, ioArgoprojWorkflowV1alpha1WorkflowSpec.podGC) &&
        Objects.equals(this.podMetadata, ioArgoprojWorkflowV1alpha1WorkflowSpec.podMetadata) &&
        Objects.equals(this.podPriority, ioArgoprojWorkflowV1alpha1WorkflowSpec.podPriority) &&
        Objects.equals(this.podPriorityClassName, ioArgoprojWorkflowV1alpha1WorkflowSpec.podPriorityClassName) &&
        Objects.equals(this.podSpecPatch, ioArgoprojWorkflowV1alpha1WorkflowSpec.podSpecPatch) &&
        Objects.equals(this.priority, ioArgoprojWorkflowV1alpha1WorkflowSpec.priority) &&
        Objects.equals(this.retryStrategy, ioArgoprojWorkflowV1alpha1WorkflowSpec.retryStrategy) &&
        Objects.equals(this.schedulerName, ioArgoprojWorkflowV1alpha1WorkflowSpec.schedulerName) &&
        Objects.equals(this.securityContext, ioArgoprojWorkflowV1alpha1WorkflowSpec.securityContext) &&
        Objects.equals(this.serviceAccountName, ioArgoprojWorkflowV1alpha1WorkflowSpec.serviceAccountName) &&
        Objects.equals(this.shutdown, ioArgoprojWorkflowV1alpha1WorkflowSpec.shutdown) &&
        Objects.equals(this.suspend, ioArgoprojWorkflowV1alpha1WorkflowSpec.suspend) &&
        Objects.equals(this.synchronization, ioArgoprojWorkflowV1alpha1WorkflowSpec.synchronization) &&
        Objects.equals(this.templateDefaults, ioArgoprojWorkflowV1alpha1WorkflowSpec.templateDefaults) &&
        Objects.equals(this.templates, ioArgoprojWorkflowV1alpha1WorkflowSpec.templates) &&
        Objects.equals(this.tolerations, ioArgoprojWorkflowV1alpha1WorkflowSpec.tolerations) &&
        Objects.equals(this.ttlStrategy, ioArgoprojWorkflowV1alpha1WorkflowSpec.ttlStrategy) &&
        Objects.equals(this.volumeClaimGC, ioArgoprojWorkflowV1alpha1WorkflowSpec.volumeClaimGC) &&
        Objects.equals(this.volumeClaimTemplates, ioArgoprojWorkflowV1alpha1WorkflowSpec.volumeClaimTemplates) &&
        Objects.equals(this.volumes, ioArgoprojWorkflowV1alpha1WorkflowSpec.volumes) &&
        Objects.equals(this.workflowMetadata, ioArgoprojWorkflowV1alpha1WorkflowSpec.workflowMetadata) &&
        Objects.equals(this.workflowTemplateRef, ioArgoprojWorkflowV1alpha1WorkflowSpec.workflowTemplateRef);
  }

  @Override
  public int hashCode() {
    return Objects.hash(activeDeadlineSeconds, affinity, archiveLogs, arguments, artifactGC, artifactRepositoryRef, automountServiceAccountToken, dnsConfig, dnsPolicy, entrypoint, executor, hooks, hostAliases, hostNetwork, imagePullSecrets, metrics, nodeSelector, onExit, parallelism, podDisruptionBudget, podGC, podMetadata, podPriority, podPriorityClassName, podSpecPatch, priority, retryStrategy, schedulerName, securityContext, serviceAccountName, shutdown, suspend, synchronization, templateDefaults, templates, tolerations, ttlStrategy, volumeClaimGC, volumeClaimTemplates, volumes, workflowMetadata, workflowTemplateRef);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class IoArgoprojWorkflowV1alpha1WorkflowSpec {\n");
    
    sb.append("    activeDeadlineSeconds: ").append(toIndentedString(activeDeadlineSeconds)).append("\n");
    sb.append("    affinity: ").append(toIndentedString(affinity)).append("\n");
    sb.append("    archiveLogs: ").append(toIndentedString(archiveLogs)).append("\n");
    sb.append("    arguments: ").append(toIndentedString(arguments)).append("\n");
    sb.append("    artifactGC: ").append(toIndentedString(artifactGC)).append("\n");
    sb.append("    artifactRepositoryRef: ").append(toIndentedString(artifactRepositoryRef)).append("\n");
    sb.append("    automountServiceAccountToken: ").append(toIndentedString(automountServiceAccountToken)).append("\n");
    sb.append("    dnsConfig: ").append(toIndentedString(dnsConfig)).append("\n");
    sb.append("    dnsPolicy: ").append(toIndentedString(dnsPolicy)).append("\n");
    sb.append("    entrypoint: ").append(toIndentedString(entrypoint)).append("\n");
    sb.append("    executor: ").append(toIndentedString(executor)).append("\n");
    sb.append("    hooks: ").append(toIndentedString(hooks)).append("\n");
    sb.append("    hostAliases: ").append(toIndentedString(hostAliases)).append("\n");
    sb.append("    hostNetwork: ").append(toIndentedString(hostNetwork)).append("\n");
    sb.append("    imagePullSecrets: ").append(toIndentedString(imagePullSecrets)).append("\n");
    sb.append("    metrics: ").append(toIndentedString(metrics)).append("\n");
    sb.append("    nodeSelector: ").append(toIndentedString(nodeSelector)).append("\n");
    sb.append("    onExit: ").append(toIndentedString(onExit)).append("\n");
    sb.append("    parallelism: ").append(toIndentedString(parallelism)).append("\n");
    sb.append("    podDisruptionBudget: ").append(toIndentedString(podDisruptionBudget)).append("\n");
    sb.append("    podGC: ").append(toIndentedString(podGC)).append("\n");
    sb.append("    podMetadata: ").append(toIndentedString(podMetadata)).append("\n");
    sb.append("    podPriority: ").append(toIndentedString(podPriority)).append("\n");
    sb.append("    podPriorityClassName: ").append(toIndentedString(podPriorityClassName)).append("\n");
    sb.append("    podSpecPatch: ").append(toIndentedString(podSpecPatch)).append("\n");
    sb.append("    priority: ").append(toIndentedString(priority)).append("\n");
    sb.append("    retryStrategy: ").append(toIndentedString(retryStrategy)).append("\n");
    sb.append("    schedulerName: ").append(toIndentedString(schedulerName)).append("\n");
    sb.append("    securityContext: ").append(toIndentedString(securityContext)).append("\n");
    sb.append("    serviceAccountName: ").append(toIndentedString(serviceAccountName)).append("\n");
    sb.append("    shutdown: ").append(toIndentedString(shutdown)).append("\n");
    sb.append("    suspend: ").append(toIndentedString(suspend)).append("\n");
    sb.append("    synchronization: ").append(toIndentedString(synchronization)).append("\n");
    sb.append("    templateDefaults: ").append(toIndentedString(templateDefaults)).append("\n");
    sb.append("    templates: ").append(toIndentedString(templates)).append("\n");
    sb.append("    tolerations: ").append(toIndentedString(tolerations)).append("\n");
    sb.append("    ttlStrategy: ").append(toIndentedString(ttlStrategy)).append("\n");
    sb.append("    volumeClaimGC: ").append(toIndentedString(volumeClaimGC)).append("\n");
    sb.append("    volumeClaimTemplates: ").append(toIndentedString(volumeClaimTemplates)).append("\n");
    sb.append("    volumes: ").append(toIndentedString(volumes)).append("\n");
    sb.append("    workflowMetadata: ").append(toIndentedString(workflowMetadata)).append("\n");
    sb.append("    workflowTemplateRef: ").append(toIndentedString(workflowTemplateRef)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

